## 22장 클린 아키텍쳐

우린 지난 수십년간 시스템 아키텍쳐에 대한 여러가디 아이디어를 봐왔다. 예를들면
- 육각형 아키텍쳐(포트와 어댑터) 
- 도메인 + 어플리케이션 / 그 외부를 포트(인터페이스)와 어댑터(포트와 바깥을 이어주는 코드)
<img width="702" alt="스크린샷 2021-06-28 오전 12 41 30" src="https://user-images.githubusercontent.com/13764108/123550663-9558c600-d7a9-11eb-9594-e7efe0ff60f3.png">
<img width="705" alt="스크린샷 2021-06-28 오전 12 43 08" src="https://user-images.githubusercontent.com/13764108/123550710-d05af980-d7a9-11eb-91c7-350adb6f1f47.png">

- DCI(Data, Context and Interaction): https://en.wikipedia.org/wiki/Data,_context_and_interaction
- BCE(Boundary-Control-Entity): Boundary(유저와 시스템의 경계) / Control(비즈니스로직) / Entity(영속성 모델, DB엔티티라 생각하면 될듯) 

이들 내용의 세부적인 내용은 모두 다르더라도 목표는 상당히 비슷한데, 바로 계층의 분리를 통한 관심사의 분리이다. 
이들 아키텍쳐는 모두 시스템이 다음과 같은 특징을 지니도록 만든다. 
- 프레임워크 독립성. 프레임워크의 제약사항으로 시스템을 욱여넣도록 강제하지 않는다. (스프링은..?)
- 테스트 용이성. 
- UI 독립성. 시스템의 나머지 부분을 변경하지 않고 UI를 쉽게 변경할 수 있다. 
- 데이터베이스 독립성. 업무규칙은 데이터베이스에 결합되지 않는다. 
- 모든 외부 에이전시에 대한 독립성. 업무규칙은 외부 세계와의 인터페이스에 대해 전혀 알지 못한다.  

다 합쳐버리기  
<img width="406" alt="스크린샷 2021-06-28 오전 12 55 25" src="https://user-images.githubusercontent.com/13764108/123551146-88d56d00-d7ab-11eb-816d-e5e03869e380.png">

### 의존성 규칙 
동심원들은 각각 다른 영역을 표현하고, 안으로 들어갈수록 고수준의 소프트웨어가 된다. 이 아키텍쳐가 동작하도록 하는 가장 중요한 규칙은 의존성 규칙이다. 

> 소스코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다. 

외부의 원에 있는 어떤 것이라도 내부의 원에서 알지 못해야하고, 쓰지 않아야 한다. 핵심은 외부의 어떤것에도 내부에 영향을 주면 안된다. 

### 엔티티

엔티티는 전사적인 핵심 업뮤 규칙을 캡슐화한다. 외부의 변경이 발생하더라도 엔티티가 변경될 가능성은 지극히 낮다. 

### 유스케이스

애플리케이션에 특화된 업무규칙을 포함한다. 이 계층의 변경이 엔티티에 영향을 줘서는 안된다. 또한 데이터베이스, UI등 외부 요소의 변경이 이 계층에 영향을 줘서도 안된다. 하지만 운영 관점에서 애플리케이션이 변경된다면 유스케이스가 영향을 받으며, 따라서 이 계층의 소프트웨어에도 영향을 줄 것이다.

### 인터페이스 어댑터

어댑터는 데이터를 유스케이스와 엔티티에게 가장 편리한 형식에서 데이터베이스나 웹같은 외부 에이전시에게 가장 편한 형식으로 변환된다. 프레젠터, 뷰, 컨트롤러는 모두 인터페이스 어댑터 계층에 속한다. 

### 프레임워크와 드라이버

가장 바깥쪽 계층은 일반적으로 DB나 웹 프레임워크 같은 도구들로 구성된다. 일반적으로는 이 계층에서는 안쪽원과 통신하기 위한 접합 코드 위외에는 특별히 더 작성해야할 코드가 그다지 많지 않다. 
프레임워크와 드라이버 계층은 모든 세부사항이 위치하는 곳이다. 우리는 이러한 것들을 모두 외부에 위치시켜서 피해를 최소화한다. (스프링에서는 DB의 커넥션풀을 설정하는부분, jpa 드라이버등 설정하는 부분등.?)

### 원은 네 개여야하만 하나? 

아니다. 네개보다 더 많은 원이 필요할 수도 있지만 중요한건 의존성 규칙은 어떤한경우에라도 적용된다는 것이다. 소스코드의 의존성은 항상 안쪽을 향한다. 

### 경계 횡단하기 

그림 22.1의 우측 하단에 원의 경계를 횡단하는 방법을 보여주는 예시가 있다. 제어흐름 대로라면 컨트롤러 -> 유스케이스 -> 프레젠터의 흐름으로 가게 되는데, 안쪽원에서 바깥쪽원을 절대 알면 안되므로 의존성 역전 원칙으로 안쪽원의 유스케이스 출력포트 라는 인터페이스를 유스케이스에서 호출 하고, 프레젠터에서 해당 인터페이스를 구현하도록 만든다. 

### 경계를 횡단하는 데이터는 어떤 모습인가 

보통 간단한 데이터 구조로 되어있다. 기본적인 구조체나, DTO 등 원하는대로 고를수도 있고, 간단한 인자로만 호출할 수도 있다. 중요한 점은 데이터 구조가 경계를 가로질러 전달된다는 사실이다. 꾀를 부려서 엔티티 객체나 데이터베이스의 행을 전달하는 일은 원치 않는다. 데이터 구조가 어떤 의존성을 가져 의존성 규칙을 위배하게 되는 일은 바라지 않는다. 
예를 들어 데이터베이스의 응답으로 데이터의 행구조를 그대로 전달해버리면 내부의 원에서 외부의 원의 무언가를 알아야 하기 때문이다. 따라서 경계를 가로질러 데이터를 전달할 때 데이터는 항상 내부의 원에서 사용하기에 가장 편리한 형태를 가져야만 한다. 

### 전형적인 시나리오

<img width="434" alt="스크린샷 2021-06-28 오전 1 36 36" src="https://user-images.githubusercontent.com/13764108/123552472-47e05700-d7b1-11eb-86a5-ec2c8bc3c208.png">
Controller에 사용자의 액션 -> InputData를 사용하여 Input Boundary 호출 -> 해당 Boundary를 호출한 Use Case Interactor에서 Entities를 사용하여 필요시 Data Access Interface도 사용하여 DB와 통신을 한 후, Output Data 형태로 가공하여 Output Boundary를 호출하면 해당 인터페이스를 구현한 Presenter가 Output Data를 사용하여 View Model 을 만들고, View가 해당 View Model을 사용하여 화면에 출력한다. 여기서 주목해야할 것은 화살표의 방향(의존성의 방향) 이 모두 바깥에서 안쪽으로 향한다는 것이다.


### 결론 

이렇게 시스템을 만들면 테스트하기 쉽고, 웹 프레임워크나 DB등 시스템의 외부요소도 야단스럽지 않게 교체할 수 있다. 
