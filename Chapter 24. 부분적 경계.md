아키텍처 경계를 완벽하게 만드는 데는 상당한 비용이 든다. 

<img src="https://user-images.githubusercontent.com/20153890/124385364-21ba3a00-dd10-11eb-8995-09a3d3e4a60a.png" width=400>

`쌍방향의 다형적 Boundary 인터페이스`, Input과 Output을 위한 데이터 구조를 만들어야 할 뿐만 아니라, 두 영역을 독립적으로 컴파일하고 배포할 수 있는 컴포넌트로 격리하는데 필요한 모든 의존성을 관리해야함. 

이렇게 만들려면 엄청난 노력이 필요함. 

애자일 커뮤니티에서의 많은 이가 이러한 종류의 선행적 설계를 탐탁치 않게 여김
- YAGNI(You Aren't Going to Need IT) 원칙을 위배하기 때문. 

하지만 아키텍트라면 이 문제를 검토하면서 "어쩌면 필요할 지도" 라는 생각이 들 수 있다.
- 그렇다면 `부분적 경계(partial boundary)`를 구현해볼 수 있다. 


<br>

## 마지막 단계를 건너뛰기
독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행한 후, 단일 컴포넌트에 그대로 모아만 두는 방법 

- 쌍방향 boundary 인터페이스도 그 컴포넌트에 있고, 입/출력 데이터 구조 등 모든 것이 준비 
- 하지만 단일 컴포넌트로 

다수의 컴포넌트를 관리하는 작업은 하지 않아도 된다. 배포 관리 부담도 없다. 

이 차이는 가볍지 않다. 

<br>

## 일차원 경계 
완벽한 형태의 아키텍처 경계는 양방향으로 격리된 상태를 유지해야 하므로 쌍방향 Boundary 인터페이스를 사용한다. 
양방향으로 격리된 상태를 유지하려면 초기 설정할 때나 지속적으로 유지할 때도 비용이 많이 든다. 

아래 그림은 추후 완벽한 형태의 경계로 확장할 수 있는 공간을 확보하고자 할 때 활용할 수 있는 더 간단한 구조를 나타낸다.

- [전략(Strategy) 패턴](https://victorydntmd.tistory.com/292)을 사용한 전형적인 사례 
<img src="https://user-images.githubusercontent.com/20153890/124385661-ad809600-dd11-11eb-84d4-9bb934efaf34.png" width=500>

이러한 분리는 매우 빠르게 붕괴될 수도 있다. 쌍방향 인터페이스가 없고 개발자와 아키텍트가 근면 성실하고 제대로 훈련되어 있지 않다면, 이 점선과 같은 비밀 통로가 생기는 일은 막을 방법이 없다. 


<br>

## 퍼사드
훨씬 더 단순한 경계는 [퍼사드 패턴](https://github.com/CodeFluxer/Clean-Architecture/blob/main/Chapter%2007.%20%EB%8B%A8%EC%9D%BC%20%EC%B1%85%EC%9E%84%20%EC%9B%90%EC%B9%99.md)이다. 

의존성 역전은 희생하는 방법이고, 경계는 Facade 클래스로만 간단히 정의된다. 
- Facade class에는 모든 서비스 클래스를 메서드 형태로 정의하고, 서비스 호출이 발생하면 해당 클래스로 호출을 전달한다. 
- 클라이언트는 이들 서비스 클래스에 직접 접근할 수 없다. 

<img src="https://user-images.githubusercontent.com/20153890/124385826-68109880-dd12-11eb-9ab8-583f485ed5a8.png" width=500>

하지만 Client가 모든 서비스 클래스에 대해 추이 종속성을 가지게 된 것을 주목하자. 
정적 언어였다면 서비스 클래스 중 하나에서 소스 코드가 변경 되면 Client도 무조건 재컴파일 해야한다. 
