#Chapter 18. 경계 해부학

> 경계: 컴포넌트를 분리하는 장벽

- 경계 횡단: 경계한쪽에서 다른 경계의 기능을 호출하여 데이터를 전달하는 일
- *적절한* 위치에서 경계를 횡단해야하는데 적절한 위치는 소스코드 의존성 관리와 연관있다
- 경계는 변경(코드 수정에 의한 컴파일, 배포)이 전파되는 것을 막는 방화벽을 구축하고 관리하는 수단으로써 존재

1. 소스 수준 분리 모드
- 각 경계가 물리적으로 엄격하게 분리되지 않음
- 경계 횡단: 단순히 함수 호출이므로 값싸다
- 배포 관점에서 하나의 단일 실행 파일 (monolith)
- 경계가 드러나지 않지만 실제로 존재한다
- 경계 횡단의 예 (저수준 클라이언트 -> 고수준 서비스)
    - 호출 되는 쪽에 data 정의
    - 컴파일, 런타임 의존성:  저수준 -> 고수준
- 경계 횓단의 예 (고수준 클라이언트 -> 저수준 서비스)
    - 호출 하는 쪽에 data 정의
    - 컴파일 의존성: 저수준 -> 고수준
    - 런타임 의존성: 고수준 -> 저수준
    - 경계를 횡단할 때: 저수준 -> 고수준
    
    
2. 배포형 컴포넌트
    - 배포 수준의 컴포넌트는 단일체와 동일하다
    - 모든 함수가 동일한 프로세서와 주소 공간에 위치
    - 컴포넌트 간 의존성르 관리하는 전략도 단일체와 동일 
    - 경계 횡단: 단순히 함수 호출이므로 값싸다 
3. 스레드
    - 하나의 컴포넌트에만 포함될 수 있고 다수의 컴포넌트에 걸칠 수 있다
   
4. 로컬 프로세스
    - 독립된 주소 공간에서 실행된다
    - 메모리 공유를 하지 못한다(통신기능을 활용해야함)
    - 저수준 프로세스가 저수준 프로세스의 플러그인이 되는 것이 아키텍쳐 관점의 목표
    - 경계 횡단: context switching 이 일어나며 비싸다
    - 고수준 프로세스의 코드에는 저수준 프로세스의 정보(이름, 물리 주소 ,레지스트리 조회키 등) 포함해서는 안된 

5. 서비스
    - 물리적 형태를 띄는 가장 강력한 경계
    - 물리적 위치에 구애받지 않는다 
    - 서비스 간의 통신은 네트워크를 통해 이루어진다(같은 프로세서가 아닐수 있음)
    - 경계 횡단: 매우 느리다
    - 저수준 서비스는 반드시 고수준 서비스에 플러그인 되어야한다
    - 고수준의 서비스의 코드에는 저수준 서비스를 특정 짓는 어떤 물리적인 정보도 포함해서는 안된다

