## 12장 컴포넌트

컴포넌트란 배포 단위이다.  
자바에서 jar로 묶어서 서버에 배포를 하는것처럼 자바에서는 jar가 배포단위, 즉 컴포넌트가 된다.  
초창기에는 메모리에서의 프로그램위치와 레이아웃을 프로그래머가 직접 제어했다.  
100쪽 코드를 보면 *200으로 시작하는데 직접 이 위치에 코드를 로드하라고 제어하는 부분. 

이렇게 로드할 위치를 정하면 재배치가 불가능했다.  
왜냐하면 소스코드에 이미 200으로 정해놓고 참조하고 있기 때문이다.  
또한 이당시에는 라이브러리 함수를 컴파일된 코드가 아니라 소스코드를 직접 포함하여 단일 프로그램으로 컴파일 했었다.
- 장치가 너무 느리고 메모리가 비쌌기때문에 문제가 있었다. 메모리가 작으니 여러번에 걸쳐서 소스코드를 읽어야 했고, 라이브러리가 클수록 컴파일이 오래걸려서 몇시간씩 걸리기도 했다. 

그래서 함수 라이브러리와 애플리케이션 코드를 분리했다.  
소스코드 형태가 아니라 이제 미리 함수라이브러리를 컴파일을 해두고, 컴파일된 바이너리를 메모리의 특정 위치에 위치에 로드시켰다.  
애플리케이션은 이 정해진 위치에 접근하게 하였다. 
- 그림 12-1의 예시에는 2000 부터 함수 라이브러리를 로드해놓고, 2000 이전까지는 애플리케이션 코드를 로드하였다. 하지만 이러한 방식은 애플리케이션이 커져서 2000이상의 메모리를 쓰게된다면 세그먼트로 분리하여서 동작하게 해야했다. 이러한 방식은 단편화가 계속되고, 문제가 있었다. (그림 12-2) 

이에대한 해결책은 재배치 가능한 바이너리 였다.  
지능적인 로더를 이용해서 재배치할 수 있는 형태의 바이너리를 생성하도록 수정하였다.  
이렇게 함으로써 함수 라이브러리를 로드할 위치와 애플리케이션을 로드할 위치를 로더에게 지시할 수 있게 되었다.  
이렇게 링킹로더라는것이 탄생했다.  
링킹로더 덕분에 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수있게 되었다.  
하지만 시간이 계속 지나자 프로그램은 훨씬 커지고, 링킹로더도 너무 느린 지경에 이르렀다.  
이시기에는 장치가 너무 느렸기때문에 수십백게의 바이너리라이브러리를 읽고 외부참조를 해석애햐 했다. 

마침내 로드와 링크가 분리되었고, 프로그래머는 느린부분인 링크과정을 맡았고 링커라는 애플리케이션을 따로 만들었다.  
그래서 링커는 링크가 완료된 하나의 재배치 코드를 만들어주었고, 로더가 메모리에 로드만 시킨 후 실행하면 되었다.  
링크 과정 자체는 여전이 느렸지만, 하나의 배치가완료된 코드는 언제라도 빠르게 실행될수 있었다. 

그리고 또 시간이 지나 1980년대가 되고, 이제 프로그램 코드가 수십만 라인이 넘는게 별일도 아니게 되었다.  
이제 링커에서 시간이 너무 많이 걸리게 되었다.  
한시간 이상이 걸리는 경우가 점점 많아지게 되었고, 프로그래머들은 헛수고를 한 것처럼 보였다.  
이 상태에서 프로그래머가 빠져나갈 구멍은 없어보였다.  
그래서 이때는 프로그램 크기가 커질수록 컴파일과 링크하는데 시간이 오래걸리게 되었다.  

하지만 시간이 지나고 디스크가 놀랄만큼 작아지고, 빨라졌다.  
그래서 프로그램이 커지는 속도보다 접근장치가 너무빨라져서 링크시간이 정말 줄어들었고 다시 초 단위가 될정도로 감소했다.  
심지어 소규모 작업이라면 이전에 쓰던 링킹로더도 사용할 수 있을만큼 빨라지게 되었다.  
자바에서도 여러개의 컴포넌트를 묶어서 .war로 배포하지 않아도 .jar파일 여러개를 실행할때마다 링크 및 로딩을 하여 실행해도 느리지 않았다.
