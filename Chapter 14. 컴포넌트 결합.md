- ADP: 의존성 비순환 원칙 
- 하향식(top-down) 설계
- SDP & SAP

## ADP: 의존성 비순환 원칙
> 컴포넌트 의존성 그래프에 순환(cycle)이 있어서는 안된다

`숙취 증후군`
- 동일한 소스 파일을 수정하는 환경에서 발생. 누군가가 마지막으로 수정한 코드 때문에 정상 동작하지 않음 

**주 단위 빌드(Weekly build)**
- 한 주의 첫 4일은 알아서 코딩하고 마지막 날 몰아서 통합
- 결국 통합 이슈를 겪게 되고 효율성 저하 

**순환 의존성 제거하기** 
- 개발 환경을 **릴리즈 가능한 컴포넌트 단위로 분리하는 것** 
- 개발자가 해당 컴포넌트가 동작하도록 만든 후, 해당 컴포넌트를 릴리스하여 다른 개발자가 사용할 수 있도록 함 
- 해당 컴포넌트를 사용하는 개발자들은 릴리즈 된 버전을 사용, 새 릴리즈를 사용은 각 팀에서 알아서 판단 

라이브러리를 생각하면 됨. 이 절차가 성공적으로 동작하려면 컴포넌트 의존성 구조에 `순환`이 있어서는 안됨. 

<img src="https://user-images.githubusercontent.com/20153890/121924046-810ed500-cd76-11eb-81c5-9540da859439.png" width=450>

방향 그래프이고, 의존성 관계는 방향이 있는 간선에 해당한다. 위 컴포넌트 의존성 구조의 경우 어떤 컴포넌트에서 시작하더라도 cycle을 생성하지 않는다. 

즉, **비순환 방향 그래프(Directed Acyclic Graph)**

- `Presenters` 로 부터 영향을 받는 컴포넌트는 `View`, `Main` 컴포넌트이다. 
- `Presenter` 담당 팀에서 새 릴리즈를 만들게 되면 이 두 컴포넌트를 작업중인 개발자는 `Presenter`의 새 릴리즈와 언제 통합할지를 결정해야한다. 
- `Presenter` 개발자가 이 컴포넌트를 테스트하고자 한다면, 단순히 현재 사용중인 버전의 `Interactors`, `Entities`를 이용하기만 하면 된다. 
- 시스템 전체를 릴리즈해야 할 때가 오면 상향식으로 진행한다. (Entities -> Database, Interactors, .. Presenters, View..)

<br>

### 순환이 컴포넌트 의존성 그래프에 미치는 영향 
새로운 요구사항이 발생해 `Entities`에 포함된 클래스 하나가 `Authorizer`에 포함된 클래스 하나를 사용하도록 변경해야한다. 
- `Entites`의 `User` 클래스에서 `Authorizer`의 `Permission` 클래스를 사용한다. 

아래 그림처럼 순환 의존성(dependency cycle)이 발생한다.

<img src="https://user-images.githubusercontent.com/20153890/121925468-e9aa8180-cd77-11eb-8990-9d351944ee6d.png" width=450>

순환은 즉각적인 문제를 일으킨다. 

순환에 의해 `Database` 컴포넌트는 `Entities`, `Interactors` 뿐만 아니라 `Authroizer` 까지 의존하게 된다. 사실상 거대한 컴포넌트가 되어버림

<br>

### 순환 끊기
컴포넌트 사이의 순환을 끊고 의존성을 다시 **비순환 방향 그래프(Directed Acyclic Graph)** 로 복구해야한다. 

1. 의존성 역전 원칙 (DIP) 
- `User` 가 필요로 하는 메서드를 제공하는 인터페이스를 생성한다. 이 인터페이스는 `Entities`에 / `Authorizer`에서는 이 인터페이스를 상속 
- 이렇게 의존성을 역전 시킴으로서 순환을 끊음 

<img src="https://user-images.githubusercontent.com/20153890/121925926-5faee880-cd78-11eb-90b9-b6c2f3624042.png" width=450>

2. Entities와 Authorizer가 모두 의존하는 새 컴포넌트 생성 
<img src="https://user-images.githubusercontent.com/20153890/121926207-b0264600-cd78-11eb-9a21-4d1fed296507.png" width=450>

### 흐트러짐 (Jitters)
위의 두번째 해결책에서 보여지듯이 컴포넌트는 요구사항에 따라 변경될 수 있다. 애플리케이션이 성장함에 따라 의존성 구조는 서서히 흐트러진다. 언제나 순환이 발생하는지를 관찰해야한다. 


<br>

## 하향식 설계
컴포넌트 구조는 하향식으로 설계될 수 없다. 컴포넌트 자체가 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화한다. 

아무런 클래스도 설계하지 않은 상태에서 컴포넌트 의존성 구조를 설계하려고 하면 실패를 할 것이다.

공통 폐쇄 원칙(CCP)에 대해 그다지 파악하고 있지 않고, 재사용 가능한 요소도 알지 못하며, 컴포넌트를 생성할 때 거의 확실히 순환 의존성이 발생할 것이다. 

컴포넌트 의존성 구조는 시스템의 논리적 설계에 발맞춰 성장하며 또 진화해야 한다.

<br>

## SDP: 안정된 의존성 원칙
> 안전성의 방향으로(더 안정된 쪽에) 의존하라. 
