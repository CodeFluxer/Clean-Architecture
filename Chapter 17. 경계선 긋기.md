## 17장 경계 : 선 긋기

소프트웨어 아키텍처는 선(경계)를 긋는 기술이다. 이 경계로 소프트웨어 요소를 분리하고 경계 한편의 요소가 다른편의 요소를 알지 못하게 막아서 핵심로직을 오염시키지 못하게 하여야 한다. 아키텍트는 인적자원의 효율을 떨어뜨리는 요소인 결합(Coupling)을 최소화 하여야 하는데 특히 너무 일찍 내려진 결정에 따른 결합을 최소화 하여야 한다.

너무 일찍 내려진 결정이란 시스템의 업무 요구사항과 관련이 없는 결정이다. 프레임워크, 데이터베이스, 웹 서버, 유틸리티 라이브러리, 의존성 주입에 대한 결정 등이 이에 해당한다. 좋은 시스템아키텍쳐란 이런 결정에 의존하지 않아야 한다.

### 두 가지 슬픈 이야기

1980년대 데스크톱 애플리케이션을 만드는 P사, 잘나갔었다. 그러나 1990년대 후반에 웹이 대세가 되기 시작하였다. 웹기반으로 애플리케이션을 만들기 위해 자바 프로그래머들을 다수 고용하고 그 프로그래머들은 서버팜이 춤추는 이상을 꿈꾸었기때문에 3티어로 구성된 리치 아키텍처를 채택했다. 서버 팜에는 GUI를 위한 서버, 미들웨어 서버, 데이터베이스 서버가 있었을것이다. 이들은 모든 도메인 객체가 세 가지 인스턴스를 가져야 한다고 너무 이른 결정을 내렸다. 각각 GUI, 미들웨어, 데이터베이스 티어를 위해서였다. 

⇒ 개판이 되었다. 개발비용이 너무너무 비싸졌다. 

결국 서버팜을 필요로하는 시스템을 한 번도 판매하지 못했다. 이는 아키텍트가 너무 이르게 결정을 내림으로써 개발 비용을 엄청나게 가중시킨 사례다. 

W사도 비슷하게 너무 일찍 SOA를 채택했으며 새로운 기능을 추가하려면 너무 많은 서비스간의 결합을 해결하고 영향받는 모든것을 전부 배포해야하는 지옥이 되었다. 

## FitNesse

인수테스트를 위한 도구를 만들때의 일이다. 

초기에 내린 결정중 하나는 웹 서버를 직접 작정하는 것이었다. 그래서 기본 뼈대만 간단하게 만든 후 나중에 다른 웹 프레임워크로 빠르게 갈아탈 수 있었다. 

또 하나는 데이터베이스에 대한 고민을 하지 말자는 것이었다. 그래서 모든 데이터에 접근하는 영역을 Interface로 간단하게 만들어두었고, 초기엔 메소드를 구현하지도 않았다. 

이제 나중에 간단한 스텁만으로도 충분하지 않게되었고 InMemory로 Interface를 구현하여 대신하였다. 이것 만으로도 일 년 내내 기능들을 차례대로 작성할 수 있었고 완전히 작동하는 FitNesse 의 최초버전을 내놓았다. 작업한 내용을 저장하는 일만 구현하지 못했을 뿐이다. 

그래서 MySql을 고려했으나 파일시스템으로도 충분하다고 결론이 났고, FileSystem으로 Interface를 구현하여 계속하여 개발했다. 나중에 MySql로 동작하는 옵션도 만들기위해서는 하루밖에 시간이 걸리지 않았고 MySql로 Interface만 구현하면 되었다. 

⇒ 궁극적으로 개발하는 기간동안 쿼리 및 데이터베이스 서버 문제등을 고려하지않아도 되어 개발시간을 매우 줄여주었고 잘 한 일이 되었다. 

### 어떻게 선을 그을까? 그리고 언제 그을까?

예를들어 GUI는 업무규칙과 상관이없기때문에 선을 그어야 한다. 데이터베이스와 GUI도 관련이 없으므로 선을 그어야 한다. 그림 17.1로 데이터베이스와 업무규칙을 떼 놓을수 있다. 다음장의 17.2에 보면 경계선이 어느위치에 그어져있는지 알수 있다. 컴포넌트 단위로 보면 17.3처럼 그릴수 있다. DB는 Business Rules를 알고있음. 반대는 모르고있음. 이러한 구조로 인해 BusinessRules는 다른 종류의 데이터베이스와도 쓸수 있다는 걸 알수있다. 

### 입력과 출력은?

가끔 GUI가 시스템이라고 생각하고 중요하게 생각하는 사람도 있는데, 여기서 중요한건 입력과 출력은 중요하지 않다는 사실이다. 무슨 말이냐면 화면, 마우스, 버튼, 음향과 같은 인터페이스가 있고 이를 조작하는 모델이 존재하는데(데이터 구조와 함수로 구성된 정교한 집합), 모델이 훨씬 중요하고 심지어 모델은 인터페이스를 필요로 하지도 않는다는 것이다. 게임에 화면이 올바르게 출력되지 않더라도 모델은 게임에서 발생하는 모든 이벤트를 모델링하며 주어진 역할을 충실하게 수행한다. 

따라서 그림 17.4와 같이 Business Rule을 GUI가 신경쓰고있는 그림으로 그릴수 있다. 

### 플러그인 아키텍쳐

앞의 그림들을 같이보면 17.5처럼 그릴 수 있다. (플러그인 형태)

그림으로 유추 할 수 있겠지만 이 아키텍쳐는 수많은 인터페이스(웹기반, 콘솔기반, 등등)를 사용 가능하고, DB도 다양하게 사용할 수 있다. 이러한 작업들이 쉬운 일은 아니겠지만 미리 플러그인 구조로 만들어 놓음으로써 이런 작업들을 현실성 있도록 만들었다. 

## 플러그인에 대한 논의

VS와 ReSharper의 관계를 생각해보자. 이 두 컴포넌트는 완전 다른 개발팀에 의해 만들어졌다. 어느 팀이 어느팀에 의해 영향을 받을까? 17.6의 그림을 보면 알 수 있다. ReSharper가 VS코드에 의존하고 있고, ReSharper는 VS에 절대로 영향을 줄 수 없다. 반면에 VS는 ReSharper를 완전히 무력화 할 수도 있다. 

이처럼 우리 시스템은 특정 모듈이 다른 모듈에 영향을 받지 않기를 바란다. 데이터 베이스를 바꾸더라도 업무규칙이 바뀌지 않기르 원한다. 시스템을 플러그인 아키텍쳐로 배치함으로써 방화벽을 만들 수 있다. 

## 결론

소프트웨어 아키텍쳐에서 경계선을 그리려면 시스템을 컴포넌트 단위로 분할 후, 핵심 업무 규칙에 해당하는 컴포넌트들을 배치하고, 나머지 컴포넌트는 플러그인으로, 즉 핵심업무와는 직접적인 관련이 없지만 필수 기능을 포함하는 컴포넌트로 분리한다. 그다음 컴포넌트 사이의 화살표가 핵심 업무를 향하도록 이들 컴포넌트의 소스를 배치한다. 

 이는 의존성 역전 원칙과 안정된 추상화 원칙을 응용한 것이다.
